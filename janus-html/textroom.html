<p>This is a plugin implementing a DataChannel only text room. As such, it does NOT support or negotiate audio or video, but only data channels, in order to provide text broadcasting features. The plugin allows users to join multiple text-only rooms via a single PeerConnection. Users can send messages either to a room in general (broadcasting), or to individual users (whispers). This plugin can be used within the context of any application that needs real-time text broadcasting (e.g., chatrooms, but not only).</p>
<p>The only message that is typically sent to the plugin through the Janus API is a <code>setup</code> message, by which the user initializes the PeerConnection itself, as explained in the <a class="el" href="#textroomsetup">Establishing a connection</a> section. Apart from that, all other messages can be exchanged directly via Data Channels. For room management purposes, though, requests like <code>create</code> , <code>edit</code> , <code>destroy</code> , <code>list</code> , <code>listparticipants</code> , <code>exists</code> and <code>announcement</code> are available through the Janus API as well: notice that in this case you'll have to use <code>request</code> and not <code>textroom</code> as the name of the request. You cannot join a room or send/receive messages via Janus API: that's only possible through the datachannel interface.</p>
<p>Each room can also be configured with an HTTP backend to contact for incoming messages. If configured, messages addressed to that room will also be forwarded, by means of an HTTP POST, to the specified address. Notice that this will only work if libcurl was available when configuring and installing Janus.</p>
<dl class="section note"><dt>Note</dt><dd>This plugin is only meant to showcase what you can do with data channels involving multiple participants at the same time. While functional, it's not inherently better or faster than doing the same thing using the Janus API messaging itself (e.g., as part of the plugin API messaging) or using existing instant messaging protocols (e.g., Jabber). In fact, while data channels are being used, you're still going through a server, so it's not really peer-to-peer. That said, the plugin can be useful if you don't plan to use any other infrastructure than Janus, and yet you also want to have text-based communication (e.g., to add a chatroom to an audio or video conference).</dd></dl>
<p>Notice that, in general, all users can create rooms. If you want to limit this functionality, you can configure an admin <code>admin_key</code> in the plugin settings. When configured, only "create" requests that include the correct <code>admin_key</code> value in an "admin_key" property will succeed, and will be rejected otherwise.</p>
<p>Rooms to make available at startup are listed in the plugin configuration file. A pre-filled configuration file is provided in <code>conf/janus.plugin.textroom.cfg</code> and includes a demo room for testing.</p>
<p>To add more static rooms or modify the existing one, you can use the following syntax:</p>
<pre class="fragment">[&lt;unique room ID&gt;]
description = This is my awesome room
is_private = true|false (whether this room should be in the public list, default=true)
secret = &lt;optional password needed for manipulating (e.g. destroying) the room&gt;
pin = &lt;optional password needed for joining the room&gt;
history = &lt;number of messages to store as a history, and send back to new participants (default=0, no history)&gt;
post = &lt;optional backend to contact via HTTP post for all incoming messages&gt;
</pre><p>As explained in the next sections, you can also create rooms programmatically.</p>
<h1 class="doxsection"><a class="anchor" id="textroomsetup"></a>
Establishing a connection</h1>
<p>While some requests to the plugin can be sent via Janus API, the actual chatroom functionality is only available via datachannel. This means that you need to establish a WebRTC PeerConnection first, if you want to take full advantage of the functionality provided by the TextRoom plugin.</p>
<p>To do that, you use the <code>setup</code> request, which doesn't require any argument:</p>
<pre class="fragment">{
        "request" : "setup"
}
</pre><p>Assuming a datachannel wasn't established already, the plugin will react to that request with a basic event, which will contain a JSEP offer too:</p>
<pre class="fragment">{
        "textroom" : "event",
        "result" : "ok"
}
</pre><p>To complete the negotiation process and establish a WebRTC PeerConnection, you need to send an empty <code>ack</code> request with your JSEP answer:</p>
<pre class="fragment">{
        "request" : "ack"
}
</pre><p>Should you need to perform an ICE restart, e.g., to keep the datachannel alive during a connection migration, you can use an empty <code>restart</code> request:</p>
<pre class="fragment">{
        "request" : "restart"
}
</pre><p>Just as in the <code>setup</code> request, this will result in the plugin sending a new JSEP offer with an attempt to restart ICE. You can use the <code>ack</code> request to provide your JSEP answer in this case too.</p>
<p>Once the datachannel is active, you can start exchanging messages there, referring to the <a class="el" href="#textroomapi">Text Room API</a> for the syntax. As explained in the intro, some request described there can be sent over Janus API too, but you'll need to use <code>request</code> instead of <code>textroom</code> as the name of the request.</p>
<h1 class="doxsection"><a class="anchor" id="textroomapi"></a>
Text Room API</h1>
<p>All TextRoom API requests sent via datachannels are addressed by a <code>textroom</code> named property, and must contain a <code>transaction</code> string property as well, which will be returned in the response. Notice that, for the sake of brevity, the <code>transaction</code> property will not be displayed in the documentation, although, as explained, it MUST be present, and WILL be included in all responses (but not in the unsolicited events, like join/leave or incoming messages).</p>
<p>To get a list of the available rooms (excluded those configured or created as private rooms) you can make use of the <code>list</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "textroom" : "list",
        "admin_key" : "&lt;plugin administrator key; optional&gt;"
}
</pre><p>A successful request will produce a list of rooms in a <code>success</code> response:</p>
<pre class="fragment">{
        "textroom" : "success",
        "list" : [              // Array of room objects
                {       // Room #1
                        "room" : &lt;unique numeric ID&gt;,
                        "description" : "&lt;Name of the room&gt;",
                        "pin_required" : &lt;true|false, depending on whether the room is PIN-protected&gt;,
                        "num_participants" : &lt;count of the participants&gt;,
                        "history" : &lt;size of history, if any&gt;
                },
                // Other rooms
        ]
}
</pre><p>To get a list of the participants in a specific room, instead, you can make use of the <code>listparticipants</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "listparticipants",
        "room" : &lt;unique numeric ID of the room&gt;
}
</pre><p>A successful request will produce a list of participants in a <code>participants</code> response:</p>
<pre class="fragment">{
        "textroom" : "success",
        "room" : &lt;unique numeric ID of the room&gt;,
        "participants" : [              // Array of participant objects
                {       // Participant #1
                        "username" : "&lt;username of participant&gt;",
                        "display" : "&lt;display name of participant, if any&gt;"
                },
                // Other participants
        ]
}
</pre><p>To create new TextRoom rooms you can use the <code>create</code> request. The API room creation supports the same fields as creation via configuration files, which means the request must be formatted as follows:</p>
<pre class="fragment">{
        "textroom" : "create",
        "room" : &lt;unique numeric room ID to assign; optional, chosen by plugin if missing&gt;,
        "admin_key" : "&lt;plugin administrator key; mandatory if configured&gt;",
        "description" : "&lt;description of room; optional&gt;",
        "secret" : "&lt;secret to query/edit the room later; optional&gt;",
        "pin" : "&lt;PIN required for participants to join room; optional&gt;",
        "is_private" : &lt;true|false, whether the room should be listable; optional, true by default&gt;,
        "history" : &lt;number of messages to store as a history, and send back to new participants (default=0, no history)&gt;,
        "post" : "&lt;backend to contact via HTTP post for all incoming messages; optional&gt;",
        "permanent" : &lt;true|false, whether the mountpoint should be saved to configuration file or not; false by default&gt;
}
</pre><p>A successful creation procedure will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "textroom" : "success",
        "room" : &lt;unique numeric ID&gt;,
        "permanent" : &lt;true if saved to config file, false if not&gt;
}
</pre><p>If you requested a permanent room but a <code>false</code> value is returned instead, good chances are that there are permission problems.</p>
<p>An error instead (and the same applies to all other requests, so this won't be repeated) would provide both an error code and a more verbose description of the cause of the issue:</p>
<pre class="fragment">{
        "textroom" : "event",
        "error_code" : &lt;numeric ID, check Macros below&gt;,
        "error" : "&lt;error description as a string&gt;"
}
</pre><p>Once a room has been created, you can still edit some (but not all) of its properties using the <code>edit</code> request. This allows you to modify the room description, secret, pin, whether it's private or not and the backend to forward incoming messages to: you won't be able to modify other more static properties, though, like the room ID for instance. If you're interested in changing the ACL, instead, check the <code>allowed</code> message. An <code>edit</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "textroom" : "edit",
        "room" : &lt;unique numeric ID of the room to edit; mandatory&gt;,
        "secret" : "&lt;room secret; mandatory if configured&gt;",
        "new_description" : "&lt;new pretty name of the room; optional&gt;",
        "new_secret" : "&lt;new password required to edit/destroy the room; optional&gt;",
        "new_pin" : "&lt;new password required to join the room; optional&gt;",
        "new_is_private" : &lt;true|false, whether the room should appear in a list request; optional&gt;,
        "permanent" : &lt;true|false, whether the room should be also removed from the config file; default=false&gt;
}
</pre><p>A successful edit procedure will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "textroom" : "edited",
        "room" : &lt;unique numeric ID&gt;,
        "permanent" : &lt;true if changes were saved to config file, false if not&gt;
}
</pre><p>On the other hand, <code>destroy</code> can be used to destroy an existing text room, whether created dynamically or statically, and has to be formatted as follows:</p>
<pre class="fragment">{
        "textroom" : "destroy",
        "room" : &lt;unique numeric ID of the room to destroy; mandatory&gt;,
        "secret" : "&lt;room secret; mandatory if configured&gt;",
        "permanent" : &lt;true|false, whether the room should be also removed from the config file; default=false&gt;
}
</pre><p>A successful destruction procedure will result in a <code>destroyed</code> response:</p>
<pre class="fragment">{
        "textroom" : "destroyed",
        "room" : &lt;unique numeric ID&gt;,
        "permanent" : &lt;true if the room was removed from config file too, false if not&gt;
}
</pre><p>This will also result in a <code>destroyed</code> event being sent to all the participants in the room, which will look like this:</p>
<pre class="fragment">{
        "textroom" : "destroyed",
        "room" : &lt;unique numeric ID of the destroyed room&gt;
}
</pre><p>You can check whether a room exists using the <code>exists</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "textroom" : "exists",
        "room" : &lt;unique numeric ID of the room to check; mandatory&gt;
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "textroom" : "success",
        "room" : &lt;unique numeric ID&gt;,
        "exists" : &lt;true|false&gt;
}
</pre><p>You can configure whether to check tokens or add/remove people who can join a room using the <code>allowed</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "textroom" : "allowed",
        "secret" : "&lt;room secret; mandatory if configured&gt;",
        "action" : "enable|disable|add|remove",
        "room" : &lt;unique numeric ID of the room to update; mandatory&gt;,
        "allowed" : [
                // Array of strings (tokens users might pass in "join", only for add|remove)
        ]
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "textroom" : "success",
        "room" : &lt;unique numeric ID&gt;,
        "allowed" : [
                // Updated, complete, list of allowed tokens (only for enable|add|remove)
        ]
}
</pre><p>If you're the administrator of a room (that is, you created it and have access to the secret) you can kick participants using the <code>kick</code> request. Notice that this only kicks the user out of the room, but does not prevent them from re-joining: to ban them, you need to first remove them from the list of authorized users (see <code>allowed</code> request) and then <code>kick</code> them. The <code>kick</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "textroom" : "kick",
        "secret" : "&lt;room secret; mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room; mandatory&gt;,
        "username" : "&lt;unique username of the participant to kick; mandatory&gt;"
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "textroom" : "success",
}
</pre><p>This will also result in a <code>kicked</code> event being sent to all the other participants in the room, which will look like this:</p>
<pre class="fragment">{
        "textroom" : "kicked",
        "room" : &lt;unique numeric ID of the room&gt;,
        "username" : "&lt;unique username of the kicked participant&gt;"
}
</pre><p>For what concerns room participation, you can join a room using the <code>join</code> request, send messages (public and private) using the <code>message</code> request, and leave a room with <code>leave</code> instead.</p>
<p>A <code>join</code> request must be formatted as follows:</p>
<pre class="fragment">{
        "textroom" : "join",
        "room" : &lt;unique numeric ID of the room to join&gt;,
        "pin" : "&lt;pin to join the room; mandatory if configured&gt;",
        "username" : "&lt;unique username to have in the room; mandatory&gt;",
        "display" : "&lt;display name to use in the room; optional&gt;",
        "token" : "&lt;invitation token, in case the room has an ACL; optional&gt;",
        "history" : &lt;true|false, whether to retrieve history messages when available (default=true)&gt;
}
</pre><p>A successful join will result in a <code>success</code> response, which will include a list of all the other participants currently in the room:</p>
<pre class="fragment">{
        "textroom" : "success",
        "participants" : [
                {
                        "username" : "&lt;username of participant #1&gt;",
                        "display" : "&lt;display name of participant #1, if any&gt;"
                },
                // Other participants
        ]
}
</pre><p>As explained previously, there's no hardcoded limit in how many rooms you can join with the same participant and on the same PeerConnection.</p>
<p>Notice that a successful <code>join</code> request will also result in a <code>join</code> event being sent to all the other participants, so that they're notified about the new participant getting in the room:</p>
<pre class="fragment">{
        "textroom" : "join",
        "room" : &lt;room ID&gt;,
        "username" : "&lt;username of new participant&gt;",
        "display" : "&lt;display name of new participant, if any&gt;"
}
</pre><p>To leave a previously joined room, instead, the <code>leave</code> request can be used, which must be formatted like this:</p>
<pre class="fragment">{
        "textroom" : "leave",
        "room" : &lt;unique numeric ID of the room to leave&gt;
}
</pre><p>A successful leave will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "textroom" : "success"
}
</pre><p>Notice that a successful <code>leave</code> request will also result in a <code>leave</code> event being sent to all the other participants, so that they're notified about the participant that just left the room:</p>
<pre class="fragment">{
        "textroom" : "leave",
        "room" : &lt;room ID&gt;,
        "username" : "&lt;username of gone participant&gt;"
}
</pre><p>Finally, the <code>message</code> request allows you to send public and private messages within the context of a room. It must be formatted like this:</p>
<pre class="fragment">{
        "textroom" : "message",
        "room" : &lt;unique numeric ID of the room this message will refer to&gt;,
        "to" : "&lt;username to send the message to; optional, only needed in case of private messages&gt;",
        "tos" : "&lt;array of usernames to send the message to; optional, only needed in case of private messages&gt;",
        "text" : "&lt;content of the message to send, as a string&gt;",
        "ack" : &lt;true|false, whether the sender wants an ack for the sent message(s); optional, true by default&gt;
}
</pre><p>A <code>message</code> with no <code>to</code> and no <code>tos</code> is considered a public message, and so will be sent to all the participants in the room. In case either <code>to</code> or <code>tos</code> is specified, instead, this is considered to be a whisper, that is a private message only meant for the specified recipients. Notice that <code>to</code> and <code>tos</code> are mutually exclusive, and you cannot specify both.</p>
<p><code>text</code> must be a string, but apart from that there's no limit on what you can put in there. It could be, for instance, a serialized JSON string, or a stringified XML document, or whatever makes sense to the application.</p>
<p>A successful message delivery will result in a <code>success</code> response, but only if <code>ack</code> was <code>true</code> in the <code>message</code> request. This was done by design, to allow users to disable explicit acks for every outgoing message, especially in case of verbose communications. In case an ack is required, the response will look like this:</p>
<pre class="fragment">{
        "textroom" : "success"
}
</pre><p>Incoming messages will come either as <code>message</code> events. In particular, <code>message</code> will notify the user about an incoming public or privave message, that is either a message that was sent to the whole room, or to the user individually:</p>
<pre class="fragment">{
        "textroom" : "message",
        "room" : &lt;room ID the message was sent to&gt;,
        "from" : "&lt;username of participant who sent the public message&gt;",
        "date" : "&lt;date/time of when the message was sent&gt;",
        "text" : "&lt;content of the message&gt;",
        "whisper" : &lt;true|false, depending on whether it's a public or private message&gt;
}
</pre><p>In case the <code>whisper</code> attribute is <code>true</code> it means the user actually received a private message from another participant in the room.</p>
<p>Another way of injecting text into rooms is by means of announcements. Announcements are basically messages sent by the room itself, rather than individual users: as such, only users or applications managing the room can send these announcements, as the room secret will be required for the purpose. The <code>announcement</code> request implements this feature in the TextRoom plugin, and must be formatted like this:</p>
<pre class="fragment">{
        "textroom" : "announcement",
        "room" : &lt;unique numeric ID of the room this announcement will be sent to&gt;,
        "secret" : "&lt;room secret; mandatory if configured&gt;",
        "text" : "&lt;content of the announcement to send, as a string&gt;"
}
</pre><p>In case the <code>announcement</code> request is accepted, the response will look like this:</p>
<pre class="fragment">{
        "textroom" : "success"
}
</pre><p>Incoming announcements will be received by participants as <code>announcement</code> events. The syntax is pretty much identical to how <code>message</code> looks like, with the difference that no <code>from</code> attribute will be included as the announcement will be seen as coming from the room itself:</p>
<pre class="fragment">{
        "textroom" : "announcement",
        "room" : &lt;room ID the announcement was sent to&gt;,
        "date" : "&lt;date/time of when the announcement was sent&gt;",
        "text" : "&lt;content of the announcement&gt;"
}
</pre> 