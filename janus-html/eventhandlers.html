<p>Controlling and monitoring a Janus instance can be done using the <a class="el" href="admin.html">Admin/Monitor API</a> which includes ways to query information related to the state of ongoing PeerConnections (ICE/DTLS state, stats, etc.). That said, while powerful and useful the Admin API is a poll-based protocol: this means that you have to query for information yourself, and if you want to keep up-to-date with what is happening, you have to do that on a regular basis. As such, things can get problematic when dealing with many sessions and handles running in your application, as you may not be immediately aware of which session/handle corresponds to what, or which of them belong to the same scenario (e.g., all PeerConnections established in the context of the same VideoRoom).</p>
<p>This is where Event Handlers can help. Just like media and transport plugins, Event Handlers plugins in Janus themselves, meaning their modular nature allows for extensibility. When enabling Event handlers, Janus and other plugins generate real-time events related to several different aspects that may be happening during its lifetime: these events are then passed to all the available event handler plugins, plugins that can then decide to do with these events whatever they want. They might choose to store these events somehow, aggregate, dump or process them, format and send them to an external application, and so on. This really depends on what these events should be used for.</p>
<p>Janus will generate events related to:</p><ul>
<li>session related events (e.g., session created/destroyed, etc.);</li>
<li>handle related events (e.g., handle attached/detached, etc.);</li>
<li>JSEP related events (e.g., got/sent offer/answer);</li>
<li>WebRTC related events (e.g., PeerConnection up/down, ICE updates, DTLS updates, etc.);</li>
<li>media related events (e.g., media started/stopped flowing, stats on packets/bytes, etc.);</li>
<li>generic events originated by the Janus core (e.g., Janus started/stopped);</li>
<li>events originated by plugins (content specific plugins themselves);</li>
<li>events originated by transports (see above);</li>
<li>events originated by external applications via the Admin API (content specific to source).</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="evhsyntax"></a>
Events format</h1>
<p>All events generated by Janus are JSON object, which have a shared header and a custom body that will depend on the type (and in some cases subtype) of the event itself.</p>
<p>The header of the event will contain some information that is usually common to all events: this includes <code>type</code> and (when needed) <code>subtype</code> of the event, a timestamp in microseconds (so that you can know exactly when the event was generated in the first place from the server's perspective, no matter it was received), and various IDs. These IDs include the session identifier (Janus session the event refers to), the handle identifier (Janus handle the event refers to) and an opaque ID (set by whoever controls the Janus API): as we'll see, all these IDs are optional, as there are events that are not related to a session in particular (e.g., a server shutdown event), but can be very important for correlation purposes when they're used.</p>
<p>The generic format of events is the following: </p><pre class="fragment">    {
        "emitter" : "&lt;string identifying the source of the event, if configured (optional)&gt;",
        "type" : &lt;numeric event type identifier&gt;,
        "subtype" : &lt;numeric event subtype identifier (specific to the event type; optional)&gt;,
        "timestamp" : &lt;time of when the event was generated&gt;,
        "session_id" : &lt;unique session identifier, if provided/available (optional)&gt;,
        "handle_id" : &lt;unique handle identifier, if provided/available (optional)&gt;,
        "opaque_id" : "&lt;user-provided opaque identifier, if provided/available (optional)&gt;",
        "event" : {
             &lt;event body, custom depending on event type&gt;
        }
    }
</pre><p>For instance, this is what an event related to a new session being created would look like:</p>
<pre class="fragment">    {
        "emitter": "MyJanusInstance",
        "type": 1,
        "timestamp": 1582211094846980,
        "session_id": 3439056127855429,
        "event": {
            "name": "created",
            "transport": {
                "transport": "janus.transport.http",
                "id": "0x60400002c2d0"
            }
        }
    }
</pre><p>Since <code>type</code> <code>1</code> is related to session events, this event basically tells us that a new session with ID <code>3439056127855429</code> was created (we know this from the <code>name</code> property in the event body) on the Janus instance called <code>MyJanusInstance</code> at the timestamp <code>1582211094846980</code> . There are no <code>subtype</code> , <code>handle_id</code> or <code>opaque_id</code> properties as they were unneeded or not applicable here.</p>
<h1 class="doxsection"><a class="anchor" id="evhtypes"></a>
Event types</h1>
<p>As we've seen from the previous example, event types are numeric. In order to figure out what you're receiving, you can refer to the following table as a reference:</p>
<table class="table table-striped">
<tbody><tr>
<th>Type</th><th>Category of event</th></tr>
<tr>
<td>1</td><td>Session related event</td></tr>
<tr>
<td>2</td><td>Handle related event</td></tr>
<tr>
<td>4</td><td>External event (injected via Admin API)</td></tr>
<tr>
<td>8</td><td>JSEP event (SDP offer/answer)</td></tr>
<tr>
<td>16</td><td>WebRTC state event (ICE/DTLS states, candidates, etc.)</td></tr>
<tr>
<td>32</td><td>Media event (media state, reports, etc.)</td></tr>
<tr>
<td>64</td><td>Plugin-originated event (e.g., event coming from VideoRoom)</td></tr>
<tr>
<td>128</td><td>Transport-originated event (e.g., WebSocket connection state)</td></tr>
<tr>
<td>256</td><td>Core event (server startup/shutdown)</td></tr>
</tbody></table>
<p>The types of events are not monotonically increasing as, internally, they're represented as a mask: this allows event handler plugins to only subscribe to a subset of them, rather than them all, when needed.</p>
<p>The event <code>type</code> property dictates the syntax of the <code>event</code> body , meaning that the body for a JSEP event (type <code>8</code> ) will for instance be very different from a media event (type <code>32</code> ). That said, the format of some events can change even within the same type: for instance, a WebRTC state event includes a lot of different notifications, including ICE states, DTLS states, local and remote candidates, selected pair, etc. In order to allow event handler recipients written in strongly typed languages to be able to use different classes for the different events, a different property called <code>subtype</code> can help further discriminate an event of a specified <code>type</code>. At the time of writing, a <code>subtype</code> attribute will only be present if the event is of type <code>256</code> (core), <code>16</code> (WebRTC) and <code>32</code> (media): all other event types have a consistent format, and so don't need this differentiation (e.g., type <code>8</code> includes both SDP offers and answers, but the nature of the SDP is indicated in an attribute that has the same name in both cases).</p>
<p>The available subtypes are the following:</p>
<table class="table table-striped">
<tbody><tr>
<th colspan="2">Core subtype</th></tr>
<tr>
<td>1</td><td>Server startup</td></tr>
<tr>
<td>2</td><td>Server shutdown</td></tr>
<tr>
<th colspan="2">WebRTC subtype</th></tr>
<tr>
<td>1</td><td>ICE state</td></tr>
<tr>
<td>2</td><td>Local candidate</td></tr>
<tr>
<td>3</td><td>Remote candidate</td></tr>
<tr>
<td>4</td><td>Selected pair</td></tr>
<tr>
<td>5</td><td>DTLS state</td></tr>
<tr>
<td>6</td><td>PeerConnection state</td></tr>
<tr>
<th colspan="2">Media subtype</th></tr>
<tr>
<td>1</td><td>Medium state</td></tr>
<tr>
<td>2</td><td>Slow link</td></tr>
<tr>
<td>3</td><td>Report/stats</td></tr>
</tbody></table>
