<p>This is a simple application that implements two different features: it allows you to record a message you send with WebRTC in the format defined in recorded.c (MJR recording) and subsequently replay this recording (or other previously recorded) through WebRTC as well. For more information on how Janus implements recordings natively and the MJR format, refer to the <a class="el" href="recordings.html">Recordings</a> documentation.</p>
<p>This application aims at showing how easy recording frames sent by a peer is, and how this recording can be re-used directly, without necessarily involving a post-processing process (e.g., through the tool we provide in <a class="el" href="janus-pp-rec_8c.html" title="Simple utility to post-process .mjr Recordings saved by Janus.">janus-pp-rec.c</a>). Notice that only audio and video can be recorded and replayed in this plugin: if you're interested in recording data channel messages (which Janus and the .mjr format do support), you should use a different plugin instead.</p>
<p>The configuration process is relatively straightforward: in the simplest configuration, you just choose where the recordings should be saved. The same folder will also be used to list the available recordings that can be replayed.</p>
<p>Notice that, by default, all recordings are public, which means any user connecting to the plugin and asking for a list of recordings will be able to obtain their IDs. Recordings can be marked as private to avoid that, meaning that users will only be able to consume such a recording if they're aware of its ID via out of band mechanisms. Marking a recording as private can be done in two different ways:</p>
<ol type="1">
<li>via the API, that is when the recording is created;</li>
<li>by setting the <code>private</code> property to <code>true</code> in the plugin configuration file, which will automatically mark all new recordings as private by default unless otherwise specified in the API request.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The application creates a special file in INI format with <span class="tt">.nfo</span> extension for each recording that is saved. This is necessary to map a specific audio .mjr file to a different video .mjr one, as they always get saved in different files. If you want to replay recordings you took in a different application (e.g., the streaming or videoroom plugins) just copy the related files in the folder you configured this plugin to use and create a .nfo file in the same folder to create a mapping, e.g.: <pre class="fragment">         [12345678]
         name = My videoroom recording
         date = 2014-10-14 17:11:26
         private = false
         audio = videoroom-audio.mjr
         video = videoroom-video.mjr
</pre></dd></dl>
<p>Data channel recordings are supported via a <code>data</code> attribute as well.</p>
<h1 class="doxsection"><a class="anchor" id="recplayapi"></a>
Record&amp;Play API</h1>
<p>The Record&amp;Play API supports several requests, some of which are synchronous and some asynchronous. There are some situations, though, (invalid JSON, invalid request) which will always result in a synchronous error response even for asynchronous requests.</p>
<p><code>list</code> , <code>update</code> and <code>configure</code> are synchronous requests, which means you'll get a response directly within the context of the transaction. <code>list</code> lists all the available recordings, while <code>update</code> forces the plugin to scan the folder of recordings again in case some were added manually and not indexed in the meanwhile. The <code>configure</code> request can be used to tweak some settings while recording a session.</p>
<p>The <code>record</code> , <code>play</code> , <code>start</code> , <code>pause</code> , <code>resume</code> and <code>stop</code> requests instead are all asynchronous, which means you'll get a notification about their success or failure in an event. <code>record</code> asks the plugin to start recording a session; <code>play</code> asks the plugin to prepare the playout of one of the previously recorded sessions; <code>start</code> starts the actual playout, and <code>stop</code> stops whatever the session was for, i.e., recording or replaying. Recording sessions can also be dynamically paused and resumed using <code>pause</code> and <code>resume</code> : the pauses will be omitted from the recording, meaning recordings will not have holes in them, and will move from one section to the other with no pause.</p>
<p>The <code>list</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "list",
        "admin_key" : "&lt;plugin administrator key; optional&gt;"
}
</pre><p>A successful request will result in an array of recordings:</p>
<pre class="fragment">{
        "recordplay" : "list",
        "list": [       // Array of recording objects
                {                       // Recording #1
                        "id": &lt;numeric ID&gt;,
                        "name": "&lt;Name of the recording&gt;",
                        "date": "&lt;Date of the recording&gt;",
                        "audio": "&lt;Audio rec file, if any; optional&gt;",
                        "video": "&lt;Video rec file, if any; optional&gt;",
                        "data": "&lt;Data rec file, if any; optional&gt;",
                        "audio_codec": "&lt;Audio codec, if any; optional&gt;",
                        "video_codec": "&lt;Video codec, if any; optional&gt;"
                },
                &lt;other recordings&gt;
        ]
}
</pre><p>An error instead (and the same applies to all other requests, so this won't be repeated) would provide both an error code and a more verbose description of the cause of the issue:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "error_code" : &lt;numeric ID, check Macros below&gt;,
        "error" : "&lt;error description as a string&gt;"
}
</pre><p>Notice that, as explained previously, the <code>list</code> request will only return the list of all recordings who were <b>not</b> marked as private. To return the list of private recordings as well, the right <code>admin_key</code> must be provided as well. In case no <code>admin_key</code> was configured, then the list of private recordings will never be returned.</p>
<p>The <code>update</code> request instead has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "update",
        "admin_key" : "&lt;plugin administrator key; mandatory, if configured&gt;"
}
</pre><p>which will always result in an immediate ack ( <code>ok</code> ):</p>
<pre class="fragment">{
        "recordplay" : "ok",
}
</pre><p>Notice that, if an <code>admin_key</code> was configured in the configuration file, it is a mandatory property to pass in an <code>update</code> request as well.</p>
<p>Coming to the asynchronous requests, <code>record</code> has to be attached to a JSEP offer (failure to do so will result in an error) and has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "record",
        "id" : &lt;unique numeric ID for the recording; optional, will be chosen by the server if missing&gt;
        "name" : "&lt;Pretty name for the recording&gt;",
        "is_private" : &lt;true|false, whether the recording should be listable; the default is what was configured in the plugin config file&gt;,
        "filename" : "&lt;Base path/name for the file (media type and extension added by the plugin); optional&gt;",
        "audiocodec" : "&lt;name of the audio codec we prefer for the recording; optional&gt;",
        "videocodec" : "&lt;name of the video codec we prefer for the recording; optional&gt;",
        "videoprofile" : "&lt;in case the video codec supports, profile to use (e.g., "2" for VP9, or "42e01f" for H.264); optional&gt;",
        "opusred" : &lt;true|false, whether RED should be negotiated for audio, if offered; optional (default=false)&gt;,
        "textdata" : "&lt;in case data channels have to be recorded, whether the data will be text (default) or binary; optional&gt;"
}
</pre><p>A successful management of this request will result in a <code>recording</code> event which will include the unique ID of the recording and a JSEP answer to complete the setup of the associated PeerConnection to record:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "recording",
                "id" : &lt;unique numeric ID&gt;,
                "is_private" : &lt;true|false, same as the request&gt;
        }
}
</pre><p>Some properties of the recording session can be tweaked dynamically via the <code>configure</code> request, and has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "configure",
        "video-bitrate-max", &lt;bitrate cap that should be forced (via REMB) on the recorder&gt;,
        "video-keyframe-interval", &lt;how often, in seconds, the plugin should send a PLI to the recorder to request a keyframe&gt;
}
</pre><p>A successful request will result in a confirmation of :</p>
<pre class="fragment">{
        "recordplay" : "configure",
        "status" : "ok",
        "settings" : {
                "video-bitrate-max" : &lt;current value of the property&gt;,
                "video-keyframe-interval" : &lt;current value of the property&gt;
        }
}
</pre><p>You can pause the recording process (meaning that RTP packets will keep on flowing but will not be recorded to file) using the <code>pause</code> request:</p>
<pre class="fragment">{
        "request" : "pause",
}
</pre><p>This will result in a <code>paused</code> status:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "paused",
                "id" : &lt;unique numeric ID of the paused recording&gt;
        }
}
</pre><p>To resume the recording process you can use the <code>resume</code> request:</p>
<pre class="fragment">{
        "request" : "resume",
}
</pre><p>This will result in a <code>resumed</code> status:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "resumed",
                "id" : &lt;unique numeric ID of the paused recording&gt;
        }
}
</pre><p>A <code>stop</code> request can interrupt the recording process and tear the associated PeerConnection down:</p>
<pre class="fragment">{
        "request" : "stop",
}
</pre><p>This will result in a <code>stopped</code> status:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "stopped",
                "id" : &lt;unique numeric ID of the interrupted recording&gt;,
                "is_private" : &lt;whether the interrupted recording is private&gt;
        }
}
</pre><p>For what concerns the playout, instead, the process is slightly different: you first choose a recording to replay, using <code>play</code> , and then start its playout using a <code>start</code> request. Just as before, a <code>stop</code> request will interrupt the playout and tear the PeerConnection down. It's very important to point out that no JSEP offer must be sent for replaying a recording: in this case, it will always be the plugin to generate a JSON offer (in response to a <code>play</code> request), which means you'll then have to provide a JSEP answer within the context of the following <code>start</code> request which will close the circle. Notice that <code>play</code> can be used to replay private recordings as well: a recording marked as private is simply not returned when retrieving the list of available recordings, but if the user is aware of a recording ID through other means, then that recording can be replayed as all other non-private recordings.</p>
<p>A <code>play</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "play",
        "id" : &lt;unique numeric ID of the recording to replay&gt;
}
</pre><p>This will result in a <code>preparing</code> status notification which will be attached to the JSEP offer originated by the plugin in order to match the media available in the recording:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "preparing",
                "id" : &lt;unique numeric ID of the recording&gt;
        }
}
</pre><p>A <code>start</code> request, which as anticipated must be attached to the JSEP answer to the previous offer sent by the plugin, has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "start",
}
</pre><p>This will result in a <code>playing</code> status notification:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "playing"
        }
}
</pre><p>Just as before, a <code>stop</code> request can interrupt the playout process at any time, and tear the associated PeerConnection down:</p>
<pre class="fragment">{
        "request" : "stop",
}
</pre><p>This will result in a <code>stopped</code> status:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "stopped"
        }
}
</pre><p>If the plugin detects a loss of the associated PeerConnection, whether as a result of a <code>stop</code> request or because the connection was closed, a <code>done</code> result notification is triggered to inform the application the recording/playout session is over:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "done",
                "id" : &lt;unique numeric ID of the completed recording&gt;,
                "is_private" : &lt;whether the completed recording is private&gt;
        }
}
</pre> 