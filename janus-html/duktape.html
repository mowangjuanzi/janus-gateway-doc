<p>This is a plugin that implements a simple bridge to JavaScript via Duktape. While the plugin implements low level stuff like media manipulation, routing, recording, etc., all the logic is demanded to an external JavaScript script. This means that the C code exposes functions to the JavaScript script (e.g., to dictate what to do with media, whether recording should be done, sending PLIs, etc.), while JavaScript exposes functions to be notified by the C code about important events (e.g., new users, WebRTC state, incoming messages, etc.).</p>
<p>Considering the C code and the JavaScript script will need some sort of "contract" in order to be able to properly interact with each other, the interface (as in method names) must be consistent, but the logic in the JavaScript script can be completely customized, so that it fits whatever requirement one has (e.g., something like the EchoTest, or something like the VideoRoom).</p>
<h1 class="doxsection"><a class="anchor" id="jsapi"></a>
JavaScript interfaces</h1>
<p>Every JavaScript script that wants to implement a Janus plugin must provide the following functions as callbacks:</p>
<ul>
<li><code>init()</code>: called when <a class="el" href="janus__duktape_8c.html" title="Janus JavaScript plugin (via Duktape)">janus_duktape.c</a> is initialized;</li>
<li><code>destroy()</code>: called when <a class="el" href="janus__duktape_8c.html" title="Janus JavaScript plugin (via Duktape)">janus_duktape.c</a> is deinitialized (Janus shutting down);</li>
<li><code>createSession()</code>: called when a new user attaches to the Janus Duktape plugin;</li>
<li><code>destroySession()</code>: called when an attached user detaches from the Janus Duktape plugin;</li>
<li><code>querySession()</code>: called when an Admin API query for a specific user gets to the Janus Duktape plugin;</li>
<li><code>handleMessage()</code>: called when a user sends a message to the Janus Duktape plugin;</li>
<li><code>setupMedia()</code>: called when a users's WebRTC PeerConnection goes up;</li>
<li><code>hangupMedia()</code>: called when a users's WebRTC PeerConnection goes down;</li>
<li><code>resumeScheduler()</code>: called by the C scheduler to resume coroutines.</li>
</ul>
<p>While <code>init()</code> expects a path to a config file (which you can ignore if unneeded), and <code>destroy()</code> and <code>resumeScheduler()</code> don't need any argument, all other functions expect at the very least a numeric session identifier, that will uniquely address a user in the plugin. Such a value is created dynamically by the C code, and so all the JavaScript script needs to do is track it as a unique session identifier when handling requests and pushing responses/events/actions towards the C code. Refer to the existing examples (e.g., <code>echotest.js</code>) to see the exact signature for all the above callbacks.</p>
<dl class="section note"><dt>Note</dt><dd>Notice that, along the above mentioned callbacks, JavaScript scripts can also implement functions like <code>incomingRtp()</code> <code>incomingRtcp()</code> <code>incomingTextData()</code> and <code>incomingBinaryData()</code> to handle those packets directly, instead of letting the C code worry about relaying/processing them. While it might make sense to handle incoming data channel messages with <code>incomingTextData()</code> or <code>incomingBinaryData</code> though, the performance impact of directly processing and manipulating RTP an RTCP packets is probably too high, and so their usage is currently discouraged. The <code>dataReady()</code> callback can be used to figure out when data can be sent. As an additional note, JavaScript scripts can also decide to implement the functions that return information about the plugin itself, namely <code>getVersion()</code> <code>getVersionString()</code> <code>getDescription()</code> <code>getName()</code> <code>getAuthor()</code> and <code>getPackage()</code>. If not implemented, the JavaScript plugin will return its own info (i.e., "janus.plugin.javascript", etc.). Most of the times, JavaScript scripts will not need to override this information, unless they really want to register their own name spaces and versioning. JavaScript scripts can also receive information on slow links via the <code>slowLink()</code> callback, in order to react accordingly: e.g., reduce the bitrate of a video sender if they, or their viewers, are experiencing issues. Finally, in case simulcast is used, JavaScript scripts may receive events on substream and/or temporal layer changes happening for receiving sessions via the <code>substreamChanged()</code> and the <code>temporalLayerChanged()</code> callbacks: this may be useful to track which layer is actually being sent, vs. what was requested.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="dtcapi"></a>
C interfaces</h1>
<p>Just as the JavaScript script needs to expose callbacks that the C code can invoke, the C code exposes methods as JavaScript functions accessible from the JavaScript script. This includes means to push events, configure how media should be routed without handling each packet in JavaScript, sending RTCP feedback, start/stop recording and so on.</p>
<p>The following are the functions the C code exposes:</p>
<ul>
<li><code>pushEvent()</code>: push an event to the user via Janus API;</li>
<li><code>eventsIsEnabled()</code>: check if Event Handlers are enabled in the core;</li>
<li><code>notifyEvent()</code>: send an event to Event Handlers;</li>
<li><code>closePc()</code>: force the closure of a PeerConnection;</li>
<li><code>configureMedium()</code>: specify whether audio/video/data can be received/sent;</li>
<li><code>addRecipient()</code>: specify which user should receive a user's media;</li>
<li><code>removeRecipient()</code>: specify which user should not receive a user's media anymore;</li>
<li><code>setBitrate()</code>: specify the bitrate to force on a user via REMB feedback;</li>
<li><code>setPliFreq()</code>: specify how often the plugin should send a PLI to this user;</li>
<li><code>setSubstream()</code>: set the target simulcast substream;</li>
<li><code>setTemporalLayer()</code>: set the target simulcast temporal layer;</li>
<li><code>sendPli()</code>: send a PLI (keyframe request);</li>
<li><code>startRecording()</code>: start recording audio, video and or data for a user;</li>
<li><code>stopRecording()</code>: start recording audio, video and or data for a user;</li>
<li><code>pokeScheduler()</code>: notify the C code that there's a coroutine to resume;</li>
<li><code>timeCallback()</code>: trigger the execution of a JavaScript function after X milliseconds.</li>
</ul>
<p>As anticipated in the previous section, almost all these methods also expect the unique session identifier to address a specific user in the plugin. This is true for all the above methods expect <code>eventsIsEnabled</code> and, more importantly, both <code>timeCallback()</code> and <code>pokeScheduler()</code> which, together with JavaScript's <code>resumeScheduler()</code>, will be clearer in the next section.</p>
<h1 class="doxsection"><a class="anchor" id="jcoroutines"></a>
JavaScript/C coroutines scheduler</h1>
<p>Duktape is a single threaded environment. While it has a concept similar to threads called coroutines, these are not threads as known in C. In order to allow for an easy to implement asynchronous behaviour in JavaScript scripts, you can leverage a scheduler implemented in the C code.</p>
<p>More specifically, when the plugin starts a dedicated thread is devoted to the only purpose of acting as a scheduler for JavaScript coroutines. This means that, whenever this C scheduler is awaken, it will call the <code>resumeScheduler()</code> function in the JavaScript script, thus allowing the JavaScript script to execute one or more pending coroutines. The C scheduler only acts when triggered, which means it's up to the JavaScript script to tell it when to wake up: this is possible via the <code>pokeScheduler()</code> function, which does nothing more than sending a simple signal to the C scheduler to wake it up. As such, it's easy for the JavaScript script to implement asynchronous behaviour, e.g.:</p>
<ol type="1">
<li>JavaScript script needs to do something asynchronously;</li>
<li>JavaScript script creates coroutine, and takes note of it somewhere;</li>
<li>JavaScript script calls <code>pokeScheduler()</code>;</li>
<li>C code sends signal to the thread acting as a scheduler;</li>
<li>when the scheduling thread wakes up, it calls <code>resumeScheduler()</code>;</li>
<li>JavaScript script resumes the previously queued coroutine.</li>
</ol>
<p>This simple mechanism is what the sample JavaScript scripts provided in this repo use, for instance, to handle incoming messages asynchronously, so you can refer to those to have an idea of how it can be used. The next section will address <a class="el" href="#jtimers">JavaScript/C time-based scheduler</a> instead.</p>
<dl class="section note"><dt>Note</dt><dd>You can implement asynchronous behaviour any way you want, and you're not required to use this C scheduler. Anyway, you must implement a method called <code>resumeScheduler()</code> anyway, as the C code checks for its presence and fails if it's not there. If you don't need it, just create an empty function that does nothing and you'll be fine.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="jtimers"></a>
JavaScript/C time-based scheduler</h1>
<p>Another helpful way to implement asynchronous behaviour is with the help of the <code>timeCallback()</code> function. Specifically, this function implements a mechanism to ask for a specific JavaScript method to be invoked after a provided amount of time. To specify the function to invoke, an optional argument to pass (which MUST be a string) and the time to wait to do that. This is particularly helpful when you're handling asynchronous behaviour that you want to inspect on a regular basis.</p>
<p>The <code>timeCallback()</code> function expects three arguments:</p>
<pre class="fragment">timeCallback(function, argument, milliseconds);
</pre><p>The only mandatory parameter is <code>function:</code> if you set <code>argument</code> to <code>null</code> no argument will be passed to <code>function</code> when it's executed; it <code>milliseconds</code> is 0, <code>function</code> will be executed as soon as possible.</p>
<pre class="fragment">// This will cause an error (timeCallback needs a function)
timeCallback();
// Invoke test() in 500 milliseconds
timeCallback("test", null, 500);
// Invoke test("ciccio") in 2 seconds
timeCallback("test", "ciccio", 2000);
</pre><p>Notice that <code>timeCallback()</code> allows you to formally recreate the mechanism <code>pokeScheduler()</code> and <code>resumeScheduler()</code> implement, as the following is pretty much an equivalent of that:</p>
<pre class="fragment">timeCallback("resumeScheduler", null, 0);
</pre><p>Anyway, <code>pokeScheduler()</code> and <code>resumeScheduler()</code> is much more compact and less verbose, and as such is preferred in cases where timing and opaque arguments are not needed.</p>
<p>Refer to the <a class="el" href="group__jspapi.html">Duktape plugin API</a> section for more information on how you can register your own C functions. </p>
